AWSTemplateFormatVersion: 2010-09-09
Description: 'AWS Template to create lambda with resource based policy'
Resources:
  cleanupBucketOnDelete:
    Type: Custom::cleanupbucket
    Properties:
      ServiceToken: !GetAtt 'DeleteS3Bucket.Arn'
      BucketName: !Ref S3Bucket
    DependsOn: S3Bucket

  DeleteS3Bucket:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Description: "Delete all objects in S3 bucket"
      Timeout: 30
      Role: !GetAtt 'LambdaBasicExecutionRole.Arn'
      Runtime: python3.9
      Environment:
        Variables:
          BUCKET_NAME: !Ref S3Bucket
      Code:
        ZipFile: |
          import json, boto3, logging
          import cfnresponse
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info("event: {}".format(event))
              try:
                  bucket = event['ResourceProperties']['BucketName']
                  logger.info("bucket: {}, event['RequestType']: {}".format(bucket,event['RequestType']))
                  if event['RequestType'] == 'Delete':
                      s3 = boto3.resource('s3')
                      bucket = s3.Bucket(bucket)
                      for obj in bucket.objects.filter():
                          logger.info("delete obj: {}".format(obj))
                          s3.Object(bucket.name, obj.key).delete()

                  sendResponseCfn(event, context, cfnresponse.SUCCESS)
              except Exception as e:
                  logger.info("Exception: {}".format(e))
                  sendResponseCfn(event, context, cfnresponse.FAILED)

          def sendResponseCfn(event, context, responseStatus):
              responseData = {}
              responseData['Data'] = {}
              cfnresponse.send(event, context, responseStatus, responseData, "CustomResourcePhysicalID")            
        
  S3Bucket:
    Type: AWS::S3::Bucket
    Description: Creating Amazon S3 bucket to hold source data for agent
    Properties:
      BucketName: !Sub agentb8-x-${AWS::AccountId}

  CustomFunctionCopyContentsToS3Bucket:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Description: "Copies files from the Blog bucket to bucket in this account"
      Timeout: 30
      Role: !GetAtt 'LambdaBasicExecutionRole.Arn'
      Runtime: python3.9
      Environment:
        Variables:
          BUCKET_NAME: !Ref S3Bucket
      Code:
        ZipFile: |
          import os
          import json
          import boto3
          import logging
          import cfnresponse

          #copy these two files from s3 to new bucket created by the CloudFormation template
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          DATA_BUCKET = "aws-blogs-artifacts-public" 
          s3_key1 = "artifacts/ML-15539/demo_csbot_db" 
          s3_key2 = "artifacts/ML-15539/customerservicebot.json" 

          def lambda_handler(event, context):
            logger.info('got event {}'.format(event))
            try:
              s3 = boto3.client('s3')
              bucket = boto3.resource('s3').Bucket(f"{os.environ.get('BUCKET_NAME')}")
              logger.info(f"bucket working with is {bucket}")
              New_bucket_name=bucket.name
              logger.info(f"new bucket name is {New_bucket_name}")
              #copying over key1
              copy_source = { 'Bucket': DATA_BUCKET, 'Key': s3_key1 }
              logger.info(f"going to copy {copy_source} -> s3://{New_bucket_name}")
              bucket.copy(copy_source, 'demo_csbot_db')
              logger.info(f"going to read {s3_key1} from bucket={bucket}")
              #copying over key2
              copy_source = { 'Bucket': DATA_BUCKET, 'Key': s3_key2 }
              logger.info(f"going to copy {copy_source} -> s3://{New_bucket_name}")
              bucket.copy(copy_source, 'customerservicebot.json')
              logger.info(f"going to read {s3_key2} from bucket={bucket}")
              response = dict(files_copied=2, error=None)
              cfnresponse.send(event, context, cfnresponse.SUCCESS, response)
            except Exception as e:
              logger.error(e)
              response = dict(files_copied=0, error=str(e))
              cfnresponse.send(event, context, cfnresponse.FAILED, response)

            return 

  Primerinvoke:
    Type: AWS::CloudFormation::CustomResource
    DependsOn: CustomFunctionCopyContentsToS3Bucket
    Version: "1.0"
    Properties:
      ServiceToken: !GetAtt CustomFunctionCopyContentsToS3Bucket.Arn

  LambdaBasicExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
        - Effect: Allow
          Principal:
            Service: lambda.amazonaws.com
          Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: arn:aws:logs:*:*:*
              - Effect: Allow
                Action:
                  - s3:*
                Resource: '*'

  ResourcePolicy:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt 'csbotBedrockAgent.Arn'
      Principal: bedrock.amazonaws.com
      SourceAccount: !Sub ${AWS::AccountId}
      SourceArn: !Sub arn:aws:bedrock:us-east-1:${AWS::AccountId}:agent/*

  csbotBedrockAgent:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Description: "Works with customer db"
      Timeout: 30
      Role: !GetAtt 'LambdaBasicExecutionRole.Arn'
      Runtime: python3.9
      Code:
        ZipFile: |
          import json
          import boto3
          import sqlite3
          from datetime import datetime

          def load_data():
              #load SQL Lite database from Amazon S3
              
              s3 = boto3.client('s3')
              # ssm = boto3.client('ssm')
              
              bucket = 'agentb8-x'
              db_name = 'database/demo_csbot_db'
              local_db = '/tmp/csbot.db'

              # create the db
              s3.download_file(bucket, db_name, local_db)
              conn = sqlite3.connect(local_db)
              print("sqllite connect done")
              cursor = conn.cursor()
              return cursor

          #Function returns all customer info for a particular customerId
          def return_customer_info(cursor, custId):
              query = 'SELECT customerName, Addr1, Addr2, City, State, Zipcode, PreferredActivity, ShoeSize, OtherInfo from CustomerInfo where customerId = ' +  str(custId)
              cursor.execute(query)
              return cursor.fetchall()
              
              
          #Function returns shoe inventory for a particular shoestyleid 
          def return_shoe_inventory(cursor, ssId):
              query = 'SELECT invcount from ShoeInventory where shoestyleId = ' + str(ssId) 
              cursor.execute(query)
              return cursor.fetchall()
              #for row in cursor.fetchall():
              #   count1 = row[0]
              #print("in total_pets")
              #print(count1)
              #return count1    
              
          #function reduces shoe inventory, updates order_details table --> all actions resulting from a shoe purchase  
          def place_shoe_order(cursor, ssId, custId):
              #update statement is incorrect.. fix this 
              print("before shoeinventory update")
              query = 'Update ShoeInventory set InvCount = InvCount -1 where ShoeStyleID = ' + str(ssId)
              ret = cursor.execute(query)
              print(ret)
              print("after shoeinventory update")
              # add check to confirm update done 
              
              today = datetime.today().strftime('%Y-%m-%d')
              query = 'INSERT INTO OrderDetails (orderdate, shoestyleId, CustomerId) VALUES ('+today+','+str(ssId)+','+ str(custId)+')'
              ret = cursor.execute(query)
              print(ret)
              # add check to confirm insert done 
              
              return 1;
              
              #for row in cursor.fetchall():
              #    name = row[0]
              #return name   
              

          #Function creates a new customer record and returns customerId
          def create_new_customer(customerName, Addr1, Addr2, City, State, Zipcode, PreferredActivity, ShoeSize, OtherInfo):
              valueStr = customerName + ","+ Addr1+ ","+  Addr2+ ","+  City+ ","+  State+ ","+  Zipcode+ ","+  PreferredActivity+ ","+  ShoeSize+ ","+  OtherInfo
              query = 'INSERT INTO CustomerInfo values (customername, addr1, addr2,state, zipcode, preferredactivity, shoesize, otherinfo) VALUES ('+valueStr +")"
              cursor.execute(query)
              #add check to confirm insert done 
              return 1


          def lambda_handler(event, context):
              responses = []
          
              cursor = load_data()
              id = 0
              for prediction in event['actionGroups']:
                  action = prediction['actionGroup']
                  api_path = prediction['apiPath']
                  
                  if api_path == '/customer':
                      print("in cust details")
                      parameters = prediction['parameters']
                      for parameter in parameters:
                          if parameter["name"] == "custId":
                              id = parameter["value"]
                      body = return_customer_info(cursor,id)
                      print(body)
                      
                  elif api_path == '/create_new_customer':
                      parameters = prediction['parameters']
                      for parameter in parameters:
                          if parameter["name"] == "cname":
                              cname = parameter["value"]
                          if parameter["name"] == "addr1":
                              addr1 = parameter["value"]
                          if parameter["name"] == "addr2":
                              addr2 = parameter["value"]
                          if parameter["name"] == "city":
                              city = parameter["value"]
                          if parameter["name"] == "state":
                              state = parameter["value"]
                          if parameter["name"] == "zipcode":
                              zipcode = parameter["value"]
                          if parameter["name"] == "preferredactivity":
                              pref = parameter["value"]
                          if parameter["name"] == "shoesize":
                              size = parameter["value"]
                          if parameter["name"] == "otherinfo":
                              other = parameter["value"]
                                
                      body = create_new_customer(cursor, cname, addr1, addr2, city, state, zipcode, pref, size, other)
                      print(body)
                  elif api_path == '/place_order':
                      print("in place order")
                      parameters = prediction['parameters']
                      for parameter in parameters:
                          if parameter["name"] == "ssId":
                              id = parameter["value"]
                          if parameter["name"] == "custId":
                              cid = parameter["value"]
                      #body = list_pets(cursor)
                      #print(body)
                      body = place_shoe_order(cursor, id, cid)
                      print(body)
                  elif api_path == '/check_inventory':
                      print("in check_inventory")
                      parameters = prediction['parameters']
                      print(parameters)
                      for parameter in parameters:
                          if parameter["name"] == "ssId":
                              id = parameter["value"]
                      print(id)
                      body = return_shoe_inventory(cursor, id)
                      print(body)
                  else:
                      body = {"{} is not a valid api, try another one.".format(api_path)}
          
                  response_body = {
                      'application/json': {
                          'body': json.dumps(body)
                      }
                  }
                  
                  action_response = {
                      'actionGroup': prediction['actionGroup'],
                      'apiPath': prediction['apiPath'],
                      'httpMethod': prediction['httpMethod'],
                      'httpStatusCode': 200,
                      'responseBody': response_body}
                  
                  responses.append(action_response)
          
              api_response = {'response': responses}
              print(api_response)
              return api_response
    
  
  
Outputs:
  S3Bucket:
    Value: !GetAtt S3Bucket.Arn
  Region:
    Description: Deployed Region
    Value: !Ref AWS::Region
